<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Synch framework: pool.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_synch.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">The Synch framework
   &#160;<span id="projectnumber">v2.5.0</span>
   </div>
   <div id="projectbrief">An open-source framework for concurrent data-structures and benchmarks</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_bba3cddd56565a95b77b098fd409d0ab.html">libconcurrent</a></li><li class="navelem"><a class="el" href="dir_3b0504cce330a6e867091f76f8160def.html">includes</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pool.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file exposes a simple API for implementing a very simple pool object. This pool object gives user the ability to allocate small chunks of memory (e.g. allocatting nodes for using them in an queue or stack implementation) in a fast and efficient way. The main purpose of this pool implentation is to add minimal overheads while benchmarking concurrent data structures, such as stacks. queues, etc. This object does not provide thread-safe methods for accessing, and thus each of the running threads should use its own instance without directely accessing the pool of any other thread.  
<a href="#details">More...</a></p>

<p><a href="pool_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structBlockObject"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8h.html#structBlockObject">BlockObject</a></td></tr>
<tr class="memdesc:structBlockObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct for the block object.  <a href="pool_8h.html#structBlockObject">More...</a><br /></td></tr>
<tr class="separator:structBlockObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structPoolBlockMetadata"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8h.html#structPoolBlockMetadata">PoolBlockMetadata</a></td></tr>
<tr class="memdesc:structPoolBlockMetadata"><td class="mdescLeft">&#160;</td><td class="mdescRight">The metadata information for a single block.  <a href="pool_8h.html#structPoolBlockMetadata">More...</a><br /></td></tr>
<tr class="separator:structPoolBlockMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structPoolBlock"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8h.html#structPoolBlock">PoolBlock</a></td></tr>
<tr class="memdesc:structPoolBlock"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct stores the metadata of the block and all the objects of the block.  <a href="pool_8h.html#structPoolBlock">More...</a><br /></td></tr>
<tr class="separator:structPoolBlock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structPoolStruct"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8h.html#structPoolStruct">PoolStruct</a></td></tr>
<tr class="memdesc:structPoolStruct"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="pool_8h.html#structPoolStruct" title="PoolStruct stores an instance of the pool object.">PoolStruct</a> stores an instance of the pool object.  <a href="pool_8h.html#structPoolStruct">More...</a><br /></td></tr>
<tr class="separator:structPoolStruct"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a51183a4fb4e89b43b358b593453288de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8h.html#a51183a4fb4e89b43b358b593453288de">POOL_INIT_ERROR</a>&#160;&#160;&#160;-1</td></tr>
<tr class="memdesc:a51183a4fb4e89b43b358b593453288de"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is returned in case of error while calling init_pool.  <a href="pool_8h.html#a51183a4fb4e89b43b358b593453288de">More...</a><br /></td></tr>
<tr class="separator:a51183a4fb4e89b43b358b593453288de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad173b08045ec3decd6988a169d719605"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8h.html#ad173b08045ec3decd6988a169d719605">POOL_INIT_SUCC</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ad173b08045ec3decd6988a169d719605"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is returned in case of success while calling init_pool.  <a href="pool_8h.html#ad173b08045ec3decd6988a169d719605">More...</a><br /></td></tr>
<tr class="separator:ad173b08045ec3decd6988a169d719605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5353b6568fe7b54ad53061532cc4d459"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8h.html#a5353b6568fe7b54ad53061532cc4d459">POOL_OBJECT_ALLOC_ERROR</a>&#160;&#160;&#160;NULL</td></tr>
<tr class="memdesc:a5353b6568fe7b54ad53061532cc4d459"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is returned in case of error while calling alloc_obj (usually system's memory is exhausted).  <a href="pool_8h.html#a5353b6568fe7b54ad53061532cc4d459">More...</a><br /></td></tr>
<tr class="separator:a5353b6568fe7b54ad53061532cc4d459"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a063aa93e8908e2473ba2cfdb7b0ad96e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8h.html#a063aa93e8908e2473ba2cfdb7b0ad96e">init_pool</a> (<a class="el" href="pool_8h.html#structPoolStruct">PoolStruct</a> *pool, uint32_t obj_size)</td></tr>
<tr class="memdesc:a063aa93e8908e2473ba2cfdb7b0ad96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes a pool with objects of size obj_size.  <a href="pool_8h.html#a063aa93e8908e2473ba2cfdb7b0ad96e">More...</a><br /></td></tr>
<tr class="separator:a063aa93e8908e2473ba2cfdb7b0ad96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e3e2d89a8c7d8f24fbde02fb0efb1e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8h.html#a82e3e2d89a8c7d8f24fbde02fb0efb1e">alloc_obj</a> (<a class="el" href="pool_8h.html#structPoolStruct">PoolStruct</a> *pool)</td></tr>
<tr class="memdesc:a82e3e2d89a8c7d8f24fbde02fb0efb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes a pool with objects of size obj_size.  <a href="pool_8h.html#a82e3e2d89a8c7d8f24fbde02fb0efb1e">More...</a><br /></td></tr>
<tr class="separator:a82e3e2d89a8c7d8f24fbde02fb0efb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6158fdfc875b6de3d1117bb133a8b4f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8h.html#a6158fdfc875b6de3d1117bb133a8b4f2">recycle_obj</a> (<a class="el" href="pool_8h.html#structPoolStruct">PoolStruct</a> *pool, void *obj)</td></tr>
<tr class="memdesc:a6158fdfc875b6de3d1117bb133a8b4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function recycles the obj object for future use.  <a href="pool_8h.html#a6158fdfc875b6de3d1117bb133a8b4f2">More...</a><br /></td></tr>
<tr class="separator:a6158fdfc875b6de3d1117bb133a8b4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227d517163e86387a44e359b7f2e1ea8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8h.html#a227d517163e86387a44e359b7f2e1ea8">rollback</a> (<a class="el" href="pool_8h.html#structPoolStruct">PoolStruct</a> *pool, uint32_t num_objs)</td></tr>
<tr class="memdesc:a227d517163e86387a44e359b7f2e1ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function cancels the last num_objs consecutive object allocations. Note that no recycle_obj operation should have been called for any of the last num_objs consecutive object allocations.  <a href="pool_8h.html#a227d517163e86387a44e359b7f2e1ea8">More...</a><br /></td></tr>
<tr class="separator:a227d517163e86387a44e359b7f2e1ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a54dfff28a8331157f6af1cc0ce5eb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pool_8h.html#a5a54dfff28a8331157f6af1cc0ce5eb9">destroy_pool</a> (<a class="el" href="pool_8h.html#structPoolStruct">PoolStruct</a> *pool)</td></tr>
<tr class="memdesc:a5a54dfff28a8331157f6af1cc0ce5eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees all the memory allocated by the pool object.  <a href="pool_8h.html#a5a54dfff28a8331157f6af1cc0ce5eb9">More...</a><br /></td></tr>
<tr class="separator:a5a54dfff28a8331157f6af1cc0ce5eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file exposes a simple API for implementing a very simple pool object. This pool object gives user the ability to allocate small chunks of memory (e.g. allocatting nodes for using them in an queue or stack implementation) in a fast and efficient way. The main purpose of this pool implentation is to add minimal overheads while benchmarking concurrent data structures, such as stacks. queues, etc. This object does not provide thread-safe methods for accessing, and thus each of the running threads should use its own instance without directely accessing the pool of any other thread. </p>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structBlockObject" id="structBlockObject"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structBlockObject">&#9670;&nbsp;</a></span>BlockObject</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct BlockObject</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A struct for the block object. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a27efa377126685282a4a91f82468fbbd"></a>struct <a class="el" href="pool_8h.html#structBlockObject">BlockObject</a> *</td>
<td class="fieldname">
next</td>
<td class="fielddoc">
The first field of a block object is a pointer to the next allocated block (if any). </td></tr>
</table>

</div>
</div>
<a name="structPoolBlockMetadata" id="structPoolBlockMetadata"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structPoolBlockMetadata">&#9670;&nbsp;</a></span>PoolBlockMetadata</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct PoolBlockMetadata</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The metadata information for a single block. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a69a09be4a2afe399dd80033144bbea95"></a>uint32_t</td>
<td class="fieldname">
object_size</td>
<td class="fielddoc">
The size of each stored object. </td></tr>
<tr><td class="fieldtype">
<a id="a7e330a62cd755c512cc5cb58b18afb51"></a>uint32_t</td>
<td class="fieldname">
entries</td>
<td class="fielddoc">
The total number of objects stored in the block. </td></tr>
<tr><td class="fieldtype">
<a id="aff36afe80afb8f5ed1df514c6667c08e"></a>uint32_t</td>
<td class="fieldname">
free_entries</td>
<td class="fielddoc">
The number of free blocks available in the block. </td></tr>
<tr><td class="fieldtype">
<a id="afb47a7ebb71da04a7a40d9bd38680beb"></a>uint32_t</td>
<td class="fieldname">
cur_entry</td>
<td class="fielddoc">
The first free block. This should be returned in the next call of alloc_obj. </td></tr>
<tr><td class="fieldtype">
<a id="a98b9e9352b75e7af8654b9aaf2d920b4"></a>struct <a class="el" href="pool_8h.html#structPoolBlock">PoolBlock</a> *</td>
<td class="fieldname">
next</td>
<td class="fielddoc">
The next block of objects. </td></tr>
<tr><td class="fieldtype">
<a id="ac0dcef7073dd29c6252fec513aca675f"></a>struct <a class="el" href="pool_8h.html#structPoolBlock">PoolBlock</a> *</td>
<td class="fieldname">
back</td>
<td class="fielddoc">
The previous block of objects. </td></tr>
</table>

</div>
</div>
<a name="structPoolBlock" id="structPoolBlock"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structPoolBlock">&#9670;&nbsp;</a></span>PoolBlock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct PoolBlock</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This struct stores the metadata of the block and all the objects of the block. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a6cc2707b96d9177edcfa3170d1921690"></a><a class="el" href="pool_8h.html#structPoolBlockMetadata">PoolBlockMetadata</a></td>
<td class="fieldname">
metadata</td>
<td class="fielddoc">
The metadata of the block. </td></tr>
<tr><td class="fieldtype">
<a id="a81e93dd551879fbb11ae9d89947feafe"></a>char</td>
<td class="fieldname">
heap[]</td>
<td class="fielddoc">
The actual storage space of the block (i.e. the objects of the block). </td></tr>
</table>

</div>
</div>
<a name="structPoolStruct" id="structPoolStruct"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structPoolStruct">&#9670;&nbsp;</a></span>PoolStruct</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct PoolStruct</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p><a class="el" href="pool_8h.html#structPoolStruct" title="PoolStruct stores an instance of the pool object.">PoolStruct</a> stores an instance of the pool object. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a125f469b088468c8803db3fff95cd6bf"></a>uint32_t</td>
<td class="fieldname">
obj_size</td>
<td class="fielddoc">
The size of the stored object (in bytes). </td></tr>
<tr><td class="fieldtype">
<a id="a2e48423f32b77e6a92c40387bd329a42"></a>uint32_t</td>
<td class="fieldname">
entries_per_block</td>
<td class="fielddoc">
The number of objects that each block of the pool contains. </td></tr>
<tr><td class="fieldtype">
<a id="a3bff5ec14ffeb0ae89a05e63d743554e"></a><a class="el" href="pool_8h.html#structBlockObject">BlockObject</a> *</td>
<td class="fieldname">
recycle_list</td>
<td class="fielddoc">
A list with the recycled items. </td></tr>
<tr><td class="fieldtype">
<a id="adbb473181dee8a988242f86f9afae877"></a><a class="el" href="pool_8h.html#structPoolBlock">PoolBlock</a> *</td>
<td class="fieldname">
head_block</td>
<td class="fielddoc">
The head of the list of blocks, where each block stores a specific amount of objects. </td></tr>
<tr><td class="fieldtype">
<a id="ac3fa0b77cad7d21bfecf4d92c94c258d"></a><a class="el" href="pool_8h.html#structPoolBlock">PoolBlock</a> *</td>
<td class="fieldname">
cur_block</td>
<td class="fielddoc">
The latest allocated block of objects. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a51183a4fb4e89b43b358b593453288de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51183a4fb4e89b43b358b593453288de">&#9670;&nbsp;</a></span>POOL_INIT_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POOL_INIT_ERROR&#160;&#160;&#160;-1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is returned in case of error while calling init_pool. </p>

</div>
</div>
<a id="ad173b08045ec3decd6988a169d719605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad173b08045ec3decd6988a169d719605">&#9670;&nbsp;</a></span>POOL_INIT_SUCC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POOL_INIT_SUCC&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is returned in case of success while calling init_pool. </p>

</div>
</div>
<a id="a5353b6568fe7b54ad53061532cc4d459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5353b6568fe7b54ad53061532cc4d459">&#9670;&nbsp;</a></span>POOL_OBJECT_ALLOC_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POOL_OBJECT_ALLOC_ERROR&#160;&#160;&#160;NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is returned in case of error while calling alloc_obj (usually system's memory is exhausted). </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a063aa93e8908e2473ba2cfdb7b0ad96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063aa93e8908e2473ba2cfdb7b0ad96e">&#9670;&nbsp;</a></span>init_pool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int init_pool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pool_8h.html#structPoolStruct">PoolStruct</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>obj_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes a pool with objects of size obj_size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>A pointer to the pool of objects. </td></tr>
    <tr><td class="paramname">obj_size</td><td>The size of objects that the pool contains. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>In case of success, init_pool returns POOL_INIT_SUCC. In case of error, init_pool returns POOL_INIT_ERROR. </dd></dl>

</div>
</div>
<a id="a82e3e2d89a8c7d8f24fbde02fb0efb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e3e2d89a8c7d8f24fbde02fb0efb1e">&#9670;&nbsp;</a></span>alloc_obj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* alloc_obj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pool_8h.html#structPoolStruct">PoolStruct</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes a pool with objects of size obj_size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>A pointer to the pool of objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to a free object is returned. Otherwise, POOL_OBJECT_ALLOC_ERROR is returned. </dd></dl>

</div>
</div>
<a id="a6158fdfc875b6de3d1117bb133a8b4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6158fdfc875b6de3d1117bb133a8b4f2">&#9670;&nbsp;</a></span>recycle_obj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void recycle_obj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pool_8h.html#structPoolStruct">PoolStruct</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function recycles the obj object for future use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>A pointer to the pool of objects. </td></tr>
    <tr><td class="paramname">obj</td><td>A pointer to the object that should be recycled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a227d517163e86387a44e359b7f2e1ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227d517163e86387a44e359b7f2e1ea8">&#9670;&nbsp;</a></span>rollback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rollback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pool_8h.html#structPoolStruct">PoolStruct</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_objs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function cancels the last num_objs consecutive object allocations. Note that no recycle_obj operation should have been called for any of the last num_objs consecutive object allocations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>A pointer to the pool of objects. </td></tr>
    <tr><td class="paramname">num_objs</td><td>The number of consecutive allocations that should be canceled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a54dfff28a8331157f6af1cc0ce5eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a54dfff28a8331157f6af1cc0ce5eb9">&#9670;&nbsp;</a></span>destroy_pool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void destroy_pool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pool_8h.html#structPoolStruct">PoolStruct</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function frees all the memory allocated by the pool object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>A pointer to the pool of objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
